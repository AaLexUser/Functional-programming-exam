# 3. Мемоизация.

```{glossary}
Мемоизация
    это техника оптимизации в программировании, при которой **сохраняются результаты** выполнения функции для определённых входных данных, чтобы избежать повторных вычислений **при последующих вызовах** с теми же аргументами. Это позволяет **ускорить выполнение программ**, особенно в задачах с ресурсоёмкими операциями или рекурсивными вызовами.
```

- Характерно для **чистых функций**
- **Clojure** предоставляет встроенную функцию `memoize`, которая оборачивает другую функцию, сохраняя её результаты в кэше.

## Как это работает:

1. **Кэширование результатов:** При первом вызове функции с конкретными аргументами результат сохраняется в памяти (например, в словаре).
2. **Повторное использование:** При повторном вызове с теми же аргументами функция возвращает сохранённый результат, не выполняя вычисления заново.

## Проблемы мемоизации

- Кеш дополнительная нагрузка, которая не всегда нужна

````{dropdown} Лекция Пенской А.В.
### Мемоизация. Python. Библиотека

Сохранение результатов выполнения функций для предотвращения повторных вычислений.

```python
import time

def dur(f):
    t = time.time()
    x = f()
    print("dur: ", time.time()-t)
    return x

def fib(n):
    if n == 0 or n == 1: return 1
    return fib(n-1) + fib(n-2)

dur(lambda: fib(32)) # => dur:  1.2896251678466797

import functools
fib = functools.cache(fib)

dur(lambda: fib(32)) # => dur:  2.8848648071289062e-05
```

----

### Мемоизация. Python. Реализация

```python
def mycache(f):
    buf = {}
    def foo(x):
        if x in buf: return buf[x]
        tmp = f(x)
        buf[x] = tmp
        return tmp
    return foo

@mycache
def fib(n):
    if n == 0 or n == 1: return 1
    return fib(n-1) + fib(n-2)

# def fib(n):
#     ...
# fib = mycache(fib)

dur(lambda: fib(32)) # => dur:  0.00015401840209960938
````

