# 4. Чисто функциональные структуры данных.

## Основные принципы

1. **Неизменяемость:**
    - Данные не изменяются после создания. Вместо этого при каждой операции создается новая версия структуры данных.
    - Это делает структуры данных потокобезопасными и упрощает параллельное выполнение.
2. **Персистентность:** Все версии структуры остаются доступными после изменений.
    - Все предыдущие версии структуры данных сохраняются и доступны для использования.
    - Это позволяет эффективно работать с историей изменений.
3. **Эффективность:**
    - Чисто функциональные структуры данных стремятся минимизировать накладные расходы на копирование, используя общие части данных между старыми и новыми версиями.

## Примеры чисто функциональных структур данных
- **Связный список (Linked Lists)**
    - Добавление элемента в начало списка создает новый список, который ссылается на старый, не изменяя его.
- **Деревья (Trees):**
    - Бинарные деревья поиска, AVL-деревья, красно-черные деревья и другие могут быть реализованы как чисто функциональные структуры.
    - При вставке или удалении элемента создается новое дерево, но большая часть структуры может быть переиспользована.
- **Персистентные массивы (Persistent Arrays):**
    - Например, в языке Clojure используется структура данных Vector, которая позволяет эффективно добавлять и изменять элементы, создавая новые версии массива.
- **Хеш-мапы (Hash Maps)**:
    - В функциональных языках, таких как Clojure или Scala, хеш-мапы реализованы как неизменяемые структуры данных, использующие trie-деревья или другие эффективные методы для обеспечения персистентности.

### Преимущества

- Обеспечивает безопасный совместный доступ - нет необходимости в операциях клонирования
- Позволяет тривиальный откат изменений, например, операции отмены, обратный путь, обработка исключений
- Автоматическая защита от гонок данных при параллельном программировании
- Более простые GC (Garbage Collection) и STM (Software Transactional Memory)
- Рекурсивная организация и обработка? (для функциональщиков проще рекурсии, для остальных итерации)

### Недостатки

- Более высокая worst-case complexity по сравнению с лучшими императивными структурами, которые часто несут логарифмические накладные расходы
- Не так хорошо изучены и документированы
- Требует управления памятью (GC или ref counts)
- Вызывает большее количество allocations (но не обязательно большее количество мест)