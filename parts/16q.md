# 16. Полиморфизм. Множественный полиморфизм.

```{glossary}
Полиморфизм (Behavior Indirection: Polymorphism)
    это возможность использовать разные программные сущности с одинаковым интерфейсом в одинаковом контексте. Indirection уровня программной модели модели.
```

## Виды полиморфизма

1. **Универсальный** (universal)
    1. Параметрический (parametric) -- обощённые структуры и код, любые данные внутри.
    1. Наследование (subtyping) -- ООП, использование наслед.
1. **Специальный** (ad-hoc)
    1. Перегрузка (overloading)
        - Ограниченный (bounded)
        - Перегрузка имён функций (func. names overloading)
    1. Приведение типов (coercion)

## Множественный полиморфизм (Multiple Dispatch).

```{glossary}
Множественный полиморфизм (Multiple Dispatch)
    Это механизм, при котором выбор реализации метода зависит от типов **всех** аргументов.
```

|Тип диспетчеризации|Синтаксис|Аргументы диспетчеризации|Степень выразительности|Выразительная возможность
|---|---|---|---|---|
|нет|$f\left(x_1, x_2, \ldots \right)$| $\{\}$ | $O(1)$ | постоянная |
|одиночная|$x_1.f\left(x_2, \ldots \right)$| $\{x_1\}$ | $O(\|X_1\|)$ | линейная |
|множественная|$f\left(x_1, x_2, \ldots \right)$| $\{x_1, x_2, \ldots \}$ | $O(\|X_1\|\|X_2\|\ldots)$ | экспоненциальная |

{cite}`Habr2019Sep` {cite}`Skillbox2022Jul`

### Ключевые особенности

- **Динамический выбор метода** на этапе выполнения (runtime) на основе реальных типов аргументов.
- Если нет реализации для такой комбинации типов, **выбрасывается исключение**.

### Преимущества множественной диспетчеризации

1. **Расширяемость:** Добавление новых типов не требует изменения существующего кода.

### Сравнение с одиночной диспетчеризацией

В Java/C++ динамически выбор метода зависит только от типа объекта, у которого он вызывается (не от аргументов).

````{dropdown} Пенской А.В.
#### Multiple Dispatch (Julia)

```julia
add(x::Int64,  y::Int64)  = x + y
add(x::Int64,  y::String) = x + parse(Int64, y)
add(x::String, y::Int64)  = parse(Int64, x) + y
add(x::String, y::String) = parse(Int64, x) + parse(Int64, y)

add(1,   41  ) # => 42
add(1,   "41") # => 42
add("1", 41  ) # => 42
add("1", "41") # => 42
add(1,   41.0) # => ?
```

```julia
# => ERROR: MethodError: no method matching add(::Int64, ::Float64)
#    Closest candidates are:
#      add(::Int64, ::Int64) at REPL[45]:1
#      ...
```

---

#### Multiple Dispatch (Common Lisp)

```lisp
(defgeneric add (x y)
  (:method (x y)
    (error "method undefined")))

(defmethod add ((x integer) (y integer)) (+ x y))
(defmethod add ((x integer) (y string) ) (+ x (parse-integer y)))
(defmethod add ((x string)  (y integer)) (+ (parse-integer x) y))
(defmethod add ((x string)  (y string) ) (+ (parse-integer x) (parse-integer y)))

(add 1   2  ) ; => 3
(add 1   "2") ; => 3
(add "1" 2  ) ; => 3
(add "1" "2") ; => 3
(add 1.0 2  )
; => debugger invoked on a SIMPLE-ERROR in thread
;    #<THREAD "main thread" RUNNING {1001560143}>:
;      method undefined
;     ...
```

---
````

```{bibliography}
:style: unsrt
:filter: docname in docnames
```
