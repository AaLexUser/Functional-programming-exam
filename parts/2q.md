# 2. Рекурсия. Хвостовая рекурсия. Структурная рекурсия.

## Обычная рекурсия

В обычной рекурсии функция вызывает саму себя до тех пор, пока не достигнет базового случая (условия выхода). 

Пример — вычисление факториала числа:

```python
def factorial(n):
    if n == 0:  # базовый случай
        return 1
    else:
        return n * factorial(n - 1)  # рекурсивный вызов
```

Здесь каждый вызов функции сохраняет свой контекст в стеке вызовов, что может привести к переполнению стека при большой глубине рекурсии.

## Хвостовая рекурсия

Хвостовая рекурсия — это частный случай рекурсии, при котором рекурсивный вызов является последней операцией в функции. Это позволяет компилятору или интерпретатору оптимизировать использование памяти.

```python
def factorial_tail(n, accumulator=1):
    if n == 0:  # базовый случай
        return accumulator
    else:
        return factorial_tail(n - 1, n * accumulator)  # хвостовой вызов
```

## Структурная рекурсия

Структурная рекурсия — базируется на рекурсивном обходе структуры данных (списка, дерева и т.д.). В этом случае функция «раскладывает» структуру на простейший элемент и (возможно) подструктуру, а затем рекурсивно обрабатывает подструктуру. При этом важно, что на каждом шаге мы «уменьшаем» или «упрощаем» структуру = гарантирует естественное условие останова.

Например, обход дерева:

```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def traverse_tree(node):
    if node is None:  # базовый случай
        return
    print(node.value)  # обработка текущего узла
    traverse_tree(node.left)  # рекурсивный обход левого поддерева
    traverse_tree(node.right)  # рекурсивный обход правого поддерева
```

Здесь рекурсия используется для обхода всех узлов дерева, следуя его структуре.

````{dropdown} Пенской
## Структурная / <br/> вполне обоснованная рекурсия

Рекурсия, аргумент вызова в "меньше" аргумента исходного.

```haskell
data List a = Cons a (List a) | Empty

example = Cons 1 (Cons 2 (Cons 3 Empty))

length Empty = 0
length (Cons x xs) = 1 + length xs
```

- Если пуст (`Empty`) -- вычисление окончено.
- Если список не пуст (`Cons`), то осуществим индуктивный переход для аргумента `Cons x xs -> xs`, тогда:
    - Если список конечен, то в нём присутствует `Empty` -- вычисление окончено.
    - Если список бесконечен, алгоритм не завершится.


### Рекурсия vs. цикл

- Зависимость между шагами рекурсии явно определена.
- Обоснованная рекурсия -> конечный алгоритм. Некоторые языки требуют обоснованной рекурсии (Coq, Agda).
- Рекурсия позволяет естественно использовать динамическую память.
- Возможно ли обойти произвольное бинарное дерево в $O(1)$ по памяти?

```c
struct BTree {
    BTree * left;
    BTree * right;
    int value;
}
```
````