# 13. Статическая верификация. Механика автоматического вывода типов.

## Статическая верификация

```{glossary}
Статическая верификация
    это процесс анализа программного кода **без его выполнения** для обнаружения потенциальных ошибок и проверки соответствия **спецификациям**.
```

### Примеры и методы

- **Синтаксический и семантический анализ (ЯП):** Выявление ошибок в структуре кода.
- **Статические анализаторы:** Инструменты вроде линтеров, санитайзеров, которые ищут уязвимости, dead code или нарушения стиля.
- **Формальные методы: (Certified programming)** Математическое доказательство корректности кода (например, с использованием Coq или TLA+).
- **Проверка типов: (IO,STM, lifetime, ADT)** Компилятор проверяет соответствие типов (например, в Java, C++).
- **Темпоральная логика: (Temporal logic tools. Пример: SystemVerilog Assertions)** позволяет проверять временные свойства систем, что особенно важно для параллельных и аппаратных систем.
- **Модельная разработка: (Model-Driven Engineering. xtUML, Switch-технология. По построению)** упрощает создание сложных систем за счёт использования моделей как основного артефакта, а также автоматизации генерации кода и тестов.

## Механика автоматического вывода типов

```{glossary}
Вывод типов (type inference)
    в программировании, у компилятора есть возможность самому логически вывести тип значения у выражения.
```

Пример:

```haskell
map f [] = []
map f (x:xs) = f x : map f xs
-- map :: _ -> _ -> _
-- map :: _ -> [_] -> _
-- map :: _ -> [_] -> [_]
-- map :: (_ -> _) -> [_] -> [_]
-- map :: forall a.
--        (a -> _) -> [a] -> [_]
-- map :: forall a b.
--        (a -> b) -> [a] -> [b]
```

В примере написана программа, реализующая отображение, приводящее функцию f к
каждому элементу списка.
1. Объявлена функция с двумя аргументами и одним результатом
1. Отмечаем тип второго элемента -- список
1. Отмечаем, что результат также является списком
1. Отмечаем, что в качестве первого аргумента используется функция, которая должна получить один аргумент и что-то вернуть
1. Используем переменную типа `a`, что символизирует собой абстрактный тип, для
определения конкретных типов в нашем отображении. Не трудно заметить, то первый
элемент списка подается на вход функции `f`, что помогает заключить, что на
второй позиции должен стоять список `[a]`.
1. Добавляем переменную `b`, которую подставляем в получившееся на 5-ом шаге
выражение.

Примечание: данный пример являет крайне простым и не касается сложных деталей и
нюансов.

### Ключевые компоненты

- **Система типов Хиндли-Милнера:** Основана на полиморфизме и алгоритме унификации.
- **Алгоритм W:** Рекурсивно обходит абстрактное синтаксическое дерево, собирает ограничения типов и решает их через унификацию.
- **Типовые переменные:** Временные метки (например, `'a`, `'b`), заменяемые конкретными типами в процессе вывода.

### Механика вывода типов

- **Сбор ограничений:** Для каждого выражения формируются уравнения типов.
Пример: Для `fun x -> x + 1` система определяет, что `x` должен быть числового типа (например, `Int`).
- **Унификация:** Решение уравнений методом подстановки.
Пример: Унификация `'a -> 'a` с `Int -> Int` даёт подстановку `'a = Int`.
- **Проверка непротиворечивости:** Если унификация невозможна (например, `Int` vs `String`), возникает ошибка.

### Итог

Автоматический вывод типов -- мощный инструмент, сочетающий удобство **динамической типизации** с надёжностью **статической верификации**. Он основан на алгоритмах **унификации** и решении **ограничений**. Однако в сложных сценариях могут потребоваться **явные аннотации** для разрешения **неоднозначностей**.

````{dropdown} Пенской А.В.
### Неявная статическая типизация

<div class="row"><div class="col">

Вывод типов (type inference)
: в программировании, у компилятора есть возможность самому логически вывести тип значения у выражения.

</div><div class="col">

```go
func main() {
 var x float32 = 123.78
 y := 23
 fmt.Printf("%T", y + x)
} // invalid operation: y + × (mismatched types int and float32)
```

<!-- default type, error -->

```go
func main() {
 var x float32 = 123.78
 y := 23 + x
 fmt.Printf("%T", y)
} // float32
```

<!-- inference type, ok -->

```haskell
map f [] = []
map f (x:xs) = f x : map f xs
-- map :: _ -> _ -> _
-- map :: _ -> [_] -> _
-- map :: _ -> [_] -> [_]
-- map :: (_ -> _) -> [_] -> [_]
-- map :: forall a.
--        (a -> _) -> [a] -> [_]
-- map :: forall a b.
--        (a -> b) -> [a] -> [b]
```

</div></div>

----

### Тотальность функций

Тотальность (total function)
: функция, определенная для всех возможных входных данных.

Примеры:

```haskell
(/) :: Int -> Int -> Int
_ / 0 = error "divide on ZERO"
a / b = ...
```

`head` -- взятие головы от списка. Варианты типизации:

```haskell
head1 :: [a] -> a
head2 :: [a] -> Maybe a
head3 :: NonEmpty a -> a
head4 :: [a] -> a + {nil}
```

[Maybe Not - Rich Hickey](https://www.youtube.com/watch?v=YR5WdGrpoug)

---

## Пример проблемы интерпретации типов

Из описания формата JSON:

<div class="row"><div class="col">

```text
number
    integer fraction exponent

integer
    digit
    onenine digits
    '-' digit
    '-' onenine digits

digits
    digit
    digit digits

digit
    '0'
    onenine
```

</div><div class="col">

```text
onenine
    '1' . '9'

fraction
    ""
    '.' digits

exponent
    ""
    'E' sign digits
    'e' sign digits
```

</div></div>

Что такое number?

---
### Что такое number в JSON?

`number` может быть: `short`, `int`, `long`, `big-int`, `float`, `double`

### Контекст

- JavaScript -- старая экосистема, разработанная для автоматизации веба "на коленке".
    - Следствие: работа с `number` как с `long` в большинстве решений.
- Haskell -- язык, сделанный любителями и профессионалами от математики.
    - Следствие 1: есть `Integer` без ограничения диапазона значений.
    - Следствие 2: библиотека Aeson (стандарт для работы с JSON) интерпретирует `number` как `Integer`.
- Crypto & Blockchain mess -- активное использование ключей.
    - Следствие: числа в 256 бит не предел.

---

#### Проблема

- Передача JSON из Haskell в веб.
- Сериализация `Integer` в `number` формирует очень длинное число, которое парсится в `long`.
- Hash перестаёт совпадать.

#### Решение

- предобработка текста JSON с заменой всех больших `number` на специальную строку;
- постобработка структуры с JSON с возвращением всех `number` к истинным значениям.

---

````