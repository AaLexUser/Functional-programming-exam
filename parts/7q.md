# 7. Функции высших порядков. Замыкания (Closure). Работа с изменяемым состоянием и областью видимости переменных в функциональных и нефункциональных языках.

## Функции высшего порядка (Higher-Order Functions, HOF)

```{glossary}
Функции высшего порядка
    это функции, которые могут принимать другие функции в качестве аргументов и/или возвращать функции как результат.
```

## Замыкания (Closures)

```{glossary}
Замыкание
    - Вложенные функции **«запоминают» [лексическую область](./20q.md)**, в которой они были созданы, и сохраняют доступ к её переменным даже после завершения выполнения внешней функции.

Чистое замыкание (Pure Closure)
    это замыкание, которое не изменяет состояние внешнего мира и не зависит от изменяемого состояния. Оно ведет себя как чистая функция (pure function), то есть:
    1. **Не имеет побочных эффектов (side effects)**: не изменяет глобальные переменные, не модифицирует внешние данные, не выполняет ввод-вывод (I/O).
    2. **Детерминировано**: для одних и тех же входных данных всегда возвращает одинаковый результат.

Грязное замыкание (Impure Closure)
    это замыкание, которое взаимодействует с внешним миром, изменяя состояние или завися от изменяемого состояния.
```

Пример **чистого замыкания**:

```python
weekdays = {
    0: 'Sunday',
    1: 'Monday',
    2: 'Tuesday',
    3: 'Wednesday',
    4: 'Thursday',
    5: 'Friday',
    6: 'Saturday',
    7: 'Sunday',
}

def n2weekdayName(n):
    return weekdays[n]

workdays = [1, 2, 3, 4, 5]

print(list(map(n2weekdayName, workdays)))
# => ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
```

Пример **грязного замыкания**:

```python
def mk_counter(begin=0):
    i = begin
    def counter():
        nonlocal i
        tmp = i
        i += 1
        return tmp
    return counter

c1 = mk_counter(0)
c2 = mk_counter(10)

print(c1(), c1(), c2(), c2(), c1()) # => 0 1 10 11 2
```

## Работа с изменяемым состоянием

**В императивных языках (например, C, Python, Java):**

- Изменяемое состояние является основой программирования.
- Переменные могут быть изменены после их создания.
- Побочные эффекты (изменение состояния) являются обычной практикой.

**В функциональных языках (например, Haskell, Erlang, Clojure):**

- Изменяемое состояние **минимизируется**.
- Данные обычно **иммутабельны (неизменяемы)**. Вместо изменения существующих данных создаются новые.
- Для работы с изменяемым состоянием используются **специальные механизмы**, например такие как монады (в Haskell) или атомы (в Clojure).

````{dropdown} Clojure работа с изменяемым состоянием

### Атомы (Atoms)

Атомы — это простейший способ работы с изменяемым состоянием. Они обеспечивают **потокобезопасное** изменение данных с помощью функции swap! или reset!.

```clojure
(def counter (atom 0))  ;; Создаем атом с начальным значением 0

;; Изменяем значение атома с помощью функции
(swap! counter inc)     ;; Увеличиваем значение на 1
(println @counter)      ;; 1

;; Сбрасываем значение атома
(reset! counter 10)     ;; Устанавливаем значение 10
(println @counter)      ;; 10
```

- `swap!` принимает функцию и применяет её к текущему значению атома.
- `reset!` устанавливает новое значение атома.
- `@counter` используется для чтения текущего значения атома.

### Ссылки (Refs)

Ссылки используются для **координированного изменения нескольких значений** в рамках **транзакций**. Они обеспечивают **ACID-гарантии** (атомарность, согласованность, изолированность, долговечность) с помощью **STM (Software Transactional Memory)**.

```clojure
(def account-a (ref 100))  ;; Создаем ссылку с начальным значением 100
(def account-b (ref 0))    ;; Создаем ссылку с начальным значением 0

;; Транзакция для перевода денег между счетами
(dosync
  (alter account-a - 50)   ;; Уменьшаем счет A на 50
  (alter account-b + 50))  ;; Увеличиваем счет B на 50

(println @account-a)       ;; 50
(println @account-b)       ;; 50
```

- `dosync` определяет транзакцию.
- `alter` изменяет значение ссылки внутри транзакции.

### Агенты (Agents)

Агенты используются для **асинхронного изменения состояния**. Они выполняют изменения в отдельном потоке и возвращают управление сразу после отправки задачи.
```clojure
(def log-agent (agent []))  ;; Создаем агент с начальным значением []

;; Асинхронно добавляем сообщение в лог
(send log-agent conj "Message 1")
(send log-agent conj "Message 2")

;; Ждем завершения всех задач агента
(await log-agent)

(println @log-agent)  ;; ["Message 1" "Message 2"]
```

- `send` отправляет задачу агенту для выполнения.
- `await` блокирует выполнение, пока агент не завершит все задачи.

и д.р.
````

## Область видимости переменных

### Лексическая область видимости (Lexical Scoping)

- Видимость переменных определяется их положением в коде.
- Вложенные функции имеют доступ к переменным внешних функций.

    **Локальные переменные:**
    - Локальные переменные ограничены блоком кода, в котором они объявлены (например, внутри функции).

    **Глобальные переменные:**
    - Глобальные переменные доступны во всей программе.

**В функциональных языках:**

- Область видимости часто ограничивается лексическим контекстом.
- Замыкания позволяют функциям «запоминать» окружение, в котором они были созданы.

### Динамическая область видимости (Dynamic Scoping)

- Видимость переменных зависит от контекста выполнения

**Подробнее:** [Question 20](./20q.md)
